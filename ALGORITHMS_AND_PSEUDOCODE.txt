================================================================================
ALGORITHMS AND PSEUDOCODE - EXPERT RAAH PLATFORM
================================================================================

This document outlines the core algorithms and pseudocode for major modules
in the Expert Raah consultancy marketplace platform.

================================================================================
1. AI-POWERED JOB-CONSULTANT MATCHING ALGORITHM
================================================================================

Algorithm Type: Hybrid Scoring Algorithm (Weighted Multi-Criteria Decision Making)
Location: backend/src/modules/ai-matching/matching.service.ts

Description:
This algorithm matches consultants to job postings using multiple weighted 
criteria including skills overlap, specialization match, experience level, 
budget compatibility, location preference, and consultant ratings.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM MatchConsultantsToJob(jobId)
INPUT: jobId (ObjectId) - Job posting identifier
OUTPUT: rankedConsultants[] - Array of matched consultants with match scores

BEGIN
    // Step 1: Fetch job details and requirements
    job ← FetchJobById(jobId)
    IF job = NULL THEN
        THROW Error("Job not found")
    END IF
    
    requiredSkills ← job.skills
    jobCategory ← job.category
    budgetMin ← job.budget.min
    budgetMax ← job.budget.max
    jobLocation ← job.location
    
    // Step 2: Fetch all verified, non-banned consultants
    consultants ← FetchConsultants({
        isVerified: TRUE,
        isBanned: FALSE,
        availability: "available"
    })
    
    matchedConsultants ← []
    
    // Step 3: Calculate match score for each consultant
    FOR EACH consultant IN consultants DO
        // Initialize scoring components
        skillScore ← 0
        specializationScore ← 0
        experienceScore ← 0
        budgetScore ← 0
        locationScore ← 0
        ratingBonus ← 0
        
        // 3.1: Calculate Skills Match Score (40% weight)
        consultantSkills ← consultant.skills
        matchingSkills ← Intersection(requiredSkills, consultantSkills)
        skillMatchPercentage ← (Count(matchingSkills) / Count(requiredSkills)) * 100
        skillScore ← skillMatchPercentage * 0.40
        
        // 3.2: Calculate Specialization Match Score (25% weight)
        IF jobCategory IN consultant.specialization THEN
            specializationScore ← 25
        ELSE
            specializationScore ← 0
        END IF
        
        // 3.3: Calculate Experience Score (15% weight)
        experienceYears ← ExtractYearsFromExperience(consultant.experience)
        IF experienceYears ≥ 5 THEN
            experienceScore ← 15
        ELSE IF experienceYears ≥ 3 THEN
            experienceScore ← 10
        ELSE IF experienceYears ≥ 1 THEN
            experienceScore ← 5
        ELSE
            experienceScore ← 0
        END IF
        
        // 3.4: Calculate Budget Compatibility Score (10% weight)
        consultantRate ← consultant.hourlyRate
        IF consultantRate ≤ budgetMax THEN
            budgetCompatibility ← 1 - ((consultantRate - budgetMin) / (budgetMax - budgetMin))
            budgetScore ← MAX(0, budgetCompatibility * 10)
        ELSE
            budgetScore ← 0
        END IF
        
        // 3.5: Calculate Location Score (5% weight)
        IF consultant.city = jobLocation THEN
            locationScore ← 5
        ELSE IF jobLocation = "Remote" THEN
            locationScore ← 3
        ELSE
            locationScore ← 0
        END IF
        
        // 3.6: Calculate Rating Bonus (5% weight)
        IF consultant.averageRating ≥ 4.5 THEN
            ratingBonus ← 5
        ELSE IF consultant.averageRating ≥ 4.0 THEN
            ratingBonus ← 3
        ELSE IF consultant.averageRating ≥ 3.5 THEN
            ratingBonus ← 1
        ELSE
            ratingBonus ← 0
        END IF
        
        // 3.7: Calculate Total Match Score (0-100)
        totalScore ← skillScore + specializationScore + experienceScore + 
                     budgetScore + locationScore + ratingBonus
        
        // 3.8: Only include consultants with minimum 30% match
        IF totalScore ≥ 30 THEN
            matchedConsultant ← {
                consultant: consultant,
                matchScore: ROUND(totalScore, 2),
                matchedSkills: matchingSkills,
                skillMatchPercentage: ROUND(skillMatchPercentage, 2)
            }
            APPEND matchedConsultant TO matchedConsultants
        END IF
    END FOR
    
    // Step 4: Sort consultants by match score (descending)
    SORT matchedConsultants BY matchScore DESC
    
    // Step 5: Return top 10 matches
    RETURN SLICE(matchedConsultants, 0, 10)
END ALGORITHM


================================================================================
2. INTELLIGENT JOB INTAKE ASSISTANT (RACHEL AI) - NLP ALGORITHM
================================================================================

Algorithm Type: Rule-Based NLP with State Machine + OpenAI GPT Integration
Location: backend/src/modules/ai-assistant/intakeAssistant.service.ts

Description:
Multi-stage conversational AI that guides buyers through job posting creation
using natural language processing, entity extraction, and contextual awareness.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM IntakeAssistantConversation(userMessage, conversationState)
INPUT: userMessage (String), conversationState (Object)
OUTPUT: assistantResponse (Object) with {message, jobData, stage, actions}

BEGIN
    currentStage ← conversationState.stage
    jobData ← conversationState.jobData
    
    // Stage 1: Initial Greeting and Domain Selection
    IF currentStage = "greeting" THEN
        domains ← ["Education", "Business", "Legal"]
        response ← "Welcome! Which domain do you need consultation for?"
        RETURN {
            message: response,
            stage: "domain_selection",
            options: domains
        }
    END IF
    
    // Stage 2: Domain Selection Processing
    IF currentStage = "domain_selection" THEN
        detectedDomain ← ExtractDomain(userMessage)
        IF detectedDomain IN ["Education", "Business", "Legal"] THEN
            jobData.category ← detectedDomain
            response ← "Great! Please describe your project requirements..."
            RETURN {
                message: response,
                stage: "description_collection",
                jobData: jobData
            }
        ELSE
            RETURN {
                message: "Please select: Education, Business, or Legal",
                stage: "domain_selection"
            }
        END IF
    END IF
    
    // Stage 3: Description Collection with NLP Analysis
    IF currentStage = "description_collection" THEN
        // Append user input to description
        IF jobData.description EXISTS THEN
            jobData.description ← jobData.description + " " + userMessage
        ELSE
            jobData.description ← userMessage
        END IF
        
        wordCount ← CountWords(jobData.description)
        
        // Require minimum 100 words for quality
        IF wordCount < 100 THEN
            remainingWords ← 100 - wordCount
            response ← "Good start! Please add " + remainingWords + " more words..."
            RETURN {
                message: response,
                stage: "description_collection",
                jobData: jobData,
                wordCount: wordCount
            }
        ELSE
            // Extract skills using NLP
            extractedSkills ← ExtractSkillsUsingNLP(jobData.description, jobData.category)
            jobData.skills ← extractedSkills
            
            response ← "I've identified these skills: " + JOIN(extractedSkills, ", ")
            response ← response + "\nWhat's your budget range (PKR)?"
            
            RETURN {
                message: response,
                stage: "budget_collection",
                jobData: jobData
            }
        END IF
    END IF
    
    // Stage 4: Budget Extraction using Regex
    IF currentStage = "budget_collection" THEN
        budgetNumbers ← ExtractNumbersFromText(userMessage)
        
        IF LENGTH(budgetNumbers) ≥ 2 THEN
            jobData.budgetMin ← MIN(budgetNumbers[0], budgetNumbers[1])
            jobData.budgetMax ← MAX(budgetNumbers[0], budgetNumbers[1])
        ELSE IF LENGTH(budgetNumbers) = 1 THEN
            jobData.budgetMin ← budgetNumbers[0]
            jobData.budgetMax ← budgetNumbers[0] * 1.5
        ELSE
            RETURN {
                message: "Please provide budget (e.g., 40000 to 60000 PKR)",
                stage: "budget_collection",
                jobData: jobData
            }
        END IF
        
        response ← "Budget: Rs " + jobData.budgetMin + " - Rs " + jobData.budgetMax
        response ← response + "\nWhat's the timeline?"
        
        RETURN {
            message: response,
            stage: "timeline_collection",
            jobData: jobData
        }
    END IF
    
    // Stage 5: Timeline Collection
    IF currentStage = "timeline_collection" THEN
        jobData.timeline ← userMessage
        response ← "Which city? (Rawalpindi/Islamabad/Lahore/Karachi/Remote)"
        
        RETURN {
            message: response,
            stage: "location_collection",
            jobData: jobData
        }
    END IF
    
    // Stage 6: Location Collection
    IF currentStage = "location_collection" THEN
        detectedCity ← ExtractCity(userMessage)
        IF detectedCity IN ["Rawalpindi", "Islamabad", "Lahore", "Karachi", "Remote"] THEN
            jobData.location ← detectedCity
            
            // Generate summary
            summary ← GenerateJobSummary(jobData)
            response ← summary + "\n\nReady to post this job?"
            
            RETURN {
                message: response,
                stage: "confirmation",
                jobData: jobData,
                complete: TRUE
            }
        ELSE
            RETURN {
                message: "Please choose valid city or Remote",
                stage: "location_collection",
                jobData: jobData
            }
        END IF
    END IF
    
    // Stage 7: Confirmation and Job Creation
    IF currentStage = "confirmation" THEN
        IF userMessage MATCHES ["yes", "confirm", "post", "proceed"] THEN
            // Create job in database
            newJob ← CreateJob(jobData)
            
            RETURN {
                message: "Job posted successfully!",
                stage: "completed",
                jobId: newJob.id,
                action: "redirect_to_dashboard"
            }
        ELSE
            RETURN {
                message: "What would you like to modify?",
                stage: "modification",
                jobData: jobData
            }
        END IF
    END IF
END ALGORITHM


// Helper Function: NLP Skill Extraction
FUNCTION ExtractSkillsUsingNLP(description, category)
BEGIN
    skillKeywords ← GetSkillKeywordsForCategory(category)
    description ← ToLowerCase(description)
    extractedSkills ← []
    
    FOR EACH skillKeyword IN skillKeywords DO
        IF description CONTAINS skillKeyword THEN
            APPEND skillKeyword TO extractedSkills
        END IF
    END FOR
    
    // Use OpenAI for advanced extraction if available
    IF OpenAI_Available THEN
        prompt ← "Extract professional skills from: " + description
        aiSkills ← CallOpenAI(prompt)
        extractedSkills ← UNION(extractedSkills, aiSkills)
    END IF
    
    RETURN UNIQUE(extractedSkills)
END FUNCTION


================================================================================
3. PAYMENT PROCESSING WITH OTP VERIFICATION ALGORITHM
================================================================================

Algorithm Type: Two-Phase Commit Protocol with OTP Challenge-Response
Location: backend/src/modules/order/order.service.ts

Description:
Secure payment processing with mobile wallet integration, OTP verification,
and escrow management for buyer-consultant transactions.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM ProcessPaymentWithOTP(orderId, proposalId, amount, paymentMethod, paymentDetails)
INPUT: orderId, proposalId, amount, paymentMethod, paymentDetails
OUTPUT: paymentSession with OTP challenge

BEGIN
    // Phase 1: Validation and Session Creation
    
    // 1.1: Validate order and proposal
    order ← FetchOrderById(orderId)
    proposal ← FetchProposalById(proposalId)
    
    IF order = NULL OR proposal = NULL THEN
        THROW Error("Invalid order or proposal")
    END IF
    
    IF order.status ≠ "pending_payment" THEN
        THROW Error("Order not in pending payment state")
    END IF
    
    IF amount < 1000 THEN
        THROW Error("Minimum payment amount is Rs 1000")
    END IF
    
    // 1.2: Create payment session
    sessionId ← GenerateUUID()
    otp ← GenerateRandomOTP(6)  // 6-digit numeric OTP
    otpHash ← HashWithSHA256(otp)
    expiryTime ← CurrentTime() + 300  // 5 minutes
    
    paymentSession ← {
        sessionId: sessionId,
        orderId: orderId,
        proposalId: proposalId,
        amount: amount,
        paymentMethod: paymentMethod,
        paymentDetails: paymentDetails,
        otpHash: otpHash,
        expiryTime: expiryTime,
        status: "pending_otp",
        attempts: 0,
        maxAttempts: 3
    }
    
    // 1.3: Store session in cache (Redis)
    StoreInCache(sessionId, paymentSession, TTL=300)
    
    // 1.4: Send OTP via payment gateway
    IF paymentMethod = "easypaisa" OR paymentMethod = "jazzcash" THEN
        mobileNumber ← paymentDetails.mobileNumber
        SendOTPViaSMS(mobileNumber, otp)
    ELSE IF paymentMethod = "card" THEN
        // Send to registered mobile
        userMobile ← GetUserMobileNumber(order.buyerId)
        SendOTPViaSMS(userMobile, otp)
    END IF
    
    // 1.5: Return session info (OTP for development only)
    IF Environment = "development" THEN
        RETURN {
            paymentSessionId: sessionId,
            developmentOtp: otp,
            expiresIn: 300
        }
    ELSE
        RETURN {
            paymentSessionId: sessionId,
            expiresIn: 300
        }
    END IF
END ALGORITHM


ALGORITHM VerifyOTPAndCompletePayment(paymentSessionId, userOtp)
INPUT: paymentSessionId, userOtp (String)
OUTPUT: paymentConfirmation with order update

BEGIN
    // Phase 2: OTP Verification and Payment Completion
    
    // 2.1: Retrieve payment session
    paymentSession ← GetFromCache(paymentSessionId)
    
    IF paymentSession = NULL THEN
        THROW Error("Invalid or expired payment session")
    END IF
    
    // 2.2: Check session expiry
    IF CurrentTime() > paymentSession.expiryTime THEN
        DeleteFromCache(paymentSessionId)
        THROW Error("OTP expired. Please restart payment.")
    END IF
    
    // 2.3: Check attempt limit
    IF paymentSession.attempts ≥ paymentSession.maxAttempts THEN
        DeleteFromCache(paymentSessionId)
        THROW Error("Maximum OTP attempts exceeded")
    END IF
    
    // 2.4: Verify OTP
    userOtpHash ← HashWithSHA256(userOtp)
    
    IF userOtpHash ≠ paymentSession.otpHash THEN
        paymentSession.attempts ← paymentSession.attempts + 1
        UpdateCache(paymentSessionId, paymentSession)
        
        remainingAttempts ← paymentSession.maxAttempts - paymentSession.attempts
        THROW Error("Invalid OTP. " + remainingAttempts + " attempts remaining.")
    END IF
    
    // 2.5: OTP verified - Process payment transaction
    BEGIN_TRANSACTION
    
    TRY
        // Create payment record
        payment ← {
            orderId: paymentSession.orderId,
            proposalId: paymentSession.proposalId,
            buyerId: order.buyerId,
            consultantId: proposal.consultantId,
            amount: paymentSession.amount,
            paymentMethod: paymentSession.paymentMethod,
            status: "completed",
            transactionId: GenerateTransactionId(),
            timestamp: CurrentTime()
        }
        
        SavePayment(payment)
        
        // Update order status
        UpdateOrder(paymentSession.orderId, {
            status: "in_progress",
            amountPaid: paymentSession.amount,
            amountPending: 0,
            paymentDate: CurrentTime()
        })
        
        // Update proposal status
        UpdateProposal(paymentSession.proposalId, {
            status: "accepted",
            acceptedDate: CurrentTime()
        })
        
        // Create escrow record
        escrow ← {
            orderId: paymentSession.orderId,
            amount: paymentSession.amount,
            status: "held",
            releaseCondition: "buyer_approval",
            holdDate: CurrentTime()
        }
        
        SaveEscrow(escrow)
        
        // Send notifications
        SendNotification(order.buyerId, "Payment successful")
        SendNotification(proposal.consultantId, "Project started")
        
        COMMIT_TRANSACTION
        
        // Clean up session
        DeleteFromCache(paymentSessionId)
        
        RETURN {
            success: TRUE,
            payment: payment,
            order: order,
            message: "Payment completed successfully"
        }
        
    CATCH Exception e
        ROLLBACK_TRANSACTION
        THROW Error("Payment processing failed: " + e.message)
    END TRY
END ALGORITHM


================================================================================
4. REAL-TIME MESSAGING WITH SOCKET.IO ALGORITHM
================================================================================

Algorithm Type: Event-Driven Architecture with Pub-Sub Pattern
Location: backend/src/socket/index.ts

Description:
Real-time bidirectional communication system for instant messaging between
buyers and consultants with online status tracking and typing indicators.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM InitializeSocketConnection(socket, userId)
INPUT: socket (WebSocket), userId (ObjectId)
OUTPUT: Connected socket with event handlers

BEGIN
    // Step 1: Authenticate and join user room
    socket.userId ← userId
    socket.JOIN_ROOM("user:" + userId)
    
    // Update user online status
    UpdateUserStatus(userId, {
        isOnline: TRUE,
        lastSeen: CurrentTime()
    })
    
    // Broadcast online status to contacts
    contactIds ← GetUserContacts(userId)
    FOR EACH contactId IN contactIds DO
        EMIT_TO_ROOM("user:" + contactId, "user_online", {
            userId: userId,
            status: "online"
        })
    END FOR
    
    // Step 2: Register event handlers
    RegisterEventHandlers(socket, userId)
    
    // Step 3: Handle disconnection
    socket.ON_DISCONNECT(() => {
        HandleDisconnection(userId)
    })
END ALGORITHM


ALGORITHM HandleSendMessage(socket, messageData)
INPUT: socket, messageData {recipientId, content, conversationId}
OUTPUT: Delivered message with acknowledgment

BEGIN
    senderId ← socket.userId
    recipientId ← messageData.recipientId
    content ← messageData.content
    
    // Step 1: Validate message
    IF LENGTH(content) = 0 OR LENGTH(content) > 5000 THEN
        EMIT_ERROR(socket, "Invalid message length")
        RETURN
    END IF
    
    // Step 2: Check if conversation exists
    conversation ← FetchConversation({
        participants: [senderId, recipientId]
    })
    
    IF conversation = NULL THEN
        // Create new conversation
        conversation ← CreateConversation({
            participants: [senderId, recipientId],
            createdAt: CurrentTime()
        })
    END IF
    
    // Step 3: Create message record
    message ← {
        conversationId: conversation.id,
        senderId: senderId,
        recipientId: recipientId,
        content: content,
        timestamp: CurrentTime(),
        isRead: FALSE,
        messageType: "text"
    }
    
    savedMessage ← SaveMessage(message)
    
    // Step 4: Update conversation metadata
    UpdateConversation(conversation.id, {
        lastMessage: content,
        lastMessageTime: CurrentTime(),
        unreadCount: INCREMENT(recipientId)
    })
    
    // Step 5: Populate sender details for display
    populatedMessage ← PopulateMessage(savedMessage, ["senderId.name", "senderId.profileImage"])
    
    // Step 6: Emit to recipient if online
    recipientSocket ← GetSocketByUserId(recipientId)
    IF recipientSocket EXISTS THEN
        EMIT_TO_SOCKET(recipientSocket, "new_message", populatedMessage)
        
        // Play notification sound
        EMIT_TO_SOCKET(recipientSocket, "play_notification")
        
        // Update unread count
        unreadCount ← GetUnreadMessageCount(recipientId)
        EMIT_TO_SOCKET(recipientSocket, "unread_count_update", {
            count: unreadCount
        })
    END IF
    
    // Step 7: Send acknowledgment to sender
    EMIT_TO_SOCKET(socket, "message_sent", {
        tempId: messageData.tempId,
        message: populatedMessage
    })
    
    // Step 8: Send push notification if recipient offline
    IF recipientSocket = NULL THEN
        SendPushNotification(recipientId, {
            title: "New message from " + GetUserName(senderId),
            body: TruncateString(content, 50),
            type: "message"
        })
    END IF
END ALGORITHM


ALGORITHM HandleTypingIndicator(socket, data)
INPUT: socket, data {recipientId, isTyping}
OUTPUT: Typing indicator to recipient

BEGIN
    senderId ← socket.userId
    recipientId ← data.recipientId
    isTyping ← data.isTyping
    
    // Find recipient socket
    recipientSocket ← GetSocketByUserId(recipientId)
    
    IF recipientSocket EXISTS THEN
        EMIT_TO_SOCKET(recipientSocket, "user_typing", {
            userId: senderId,
            isTyping: isTyping
        })
        
        // Auto-clear typing indicator after 3 seconds
        IF isTyping = TRUE THEN
            SetTimeout(() => {
                EMIT_TO_SOCKET(recipientSocket, "user_typing", {
                    userId: senderId,
                    isTyping: FALSE
                })
            }, 3000)
        END IF
    END IF
END ALGORITHM


ALGORITHM HandleDisconnection(userId)
INPUT: userId (ObjectId)
OUTPUT: Updated online status

BEGIN
    // Update user status to offline
    UpdateUserStatus(userId, {
        isOnline: FALSE,
        lastSeen: CurrentTime()
    })
    
    // Broadcast offline status to contacts
    contactIds ← GetUserContacts(userId)
    FOR EACH contactId IN contactIds DO
        EMIT_TO_ROOM("user:" + contactId, "user_offline", {
            userId: userId,
            status: "offline",
            lastSeen: CurrentTime()
        })
    END FOR
    
    // Clean up socket references
    RemoveSocketFromRegistry(userId)
END ALGORITHM


================================================================================
5. CONSULTANT SEARCH AND FILTER ALGORITHM
================================================================================

Algorithm Type: Multi-Field Search with MongoDB Aggregation Pipeline
Location: backend/src/modules/consultant/consultant.service.ts

Description:
Advanced search algorithm that combines text search, filters, and aggregation
to find consultants matching buyer criteria with pagination support.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM SearchAndFilterConsultants(searchQuery, filters, pagination)
INPUT: searchQuery (String), filters (Object), pagination (Object)
OUTPUT: consultants[] with metadata

BEGIN
    // Step 1: Initialize query parameters
    searchText ← searchQuery.trim()
    page ← pagination.page OR 1
    limit ← pagination.limit OR 10
    skip ← (page - 1) * limit
    
    // Step 2: Build base filter
    baseFilter ← {
        isVerified: TRUE,
        isBanned: FALSE
    }
    
    // Apply additional filters
    IF filters.city EXISTS THEN
        baseFilter.city ← filters.city
    END IF
    
    IF filters.specialization EXISTS THEN
        baseFilter.specialization ← {
            $in: SplitByComma(filters.specialization)
        }
    END IF
    
    IF filters.minRating EXISTS THEN
        baseFilter.averageRating ← {
            $gte: ToNumber(filters.minRating)
        }
    END IF
    
    IF filters.availability EXISTS THEN
        baseFilter.availability ← filters.availability
    END IF
    
    // Step 3: Build aggregation pipeline for search
    IF searchText IS NOT EMPTY THEN
        pipeline ← [
            // Stage 1: Lookup user details
            {
                $lookup: {
                    from: "users",
                    localField: "userId",
                    foreignField: "_id",
                    as: "userDetails"
                }
            },
            
            // Stage 2: Unwind user array
            {
                $unwind: "$userDetails"
            },
            
            // Stage 3: Apply base filters and search
            {
                $match: {
                    ...baseFilter,
                    $or: [
                        { title: { $regex: searchText, $options: "i" } },
                        { bio: { $regex: searchText, $options: "i" } },
                        { specialization: { $regex: searchText, $options: "i" } },
                        { skills: { $regex: searchText, $options: "i" } },
                        { "userDetails.name": { $regex: searchText, $options: "i" } },
                        { "userDetails.email": { $regex: searchText, $options: "i" } }
                    ]
                }
            },
            
            // Stage 4: Sort by relevance and rating
            {
                $sort: {
                    averageRating: -1,
                    totalReviews: -1,
                    createdAt: -1
                }
            },
            
            // Stage 5: Pagination
            { $skip: skip },
            { $limit: limit },
            
            // Stage 6: Project final shape
            {
                $project: {
                    _id: 1,
                    userId: {
                        _id: "$userDetails._id",
                        name: "$userDetails.name",
                        email: "$userDetails.email",
                        profileImage: "$userDetails.profileImage",
                        isOnline: "$userDetails.isOnline",
                        isBanned: "$userDetails.isBanned"
                    },
                    title: 1,
                    bio: 1,
                    specialization: 1,
                    hourlyRate: 1,
                    experience: 1,
                    skills: 1,
                    city: 1,
                    rating: 1,
                    averageRating: 1,
                    totalReviews: 1,
                    availability: 1,
                    isVerified: 1,
                    createdAt: 1,
                    updatedAt: 1
                }
            }
        ]
        
        // Execute aggregation
        consultants ← ExecuteAggregation("consultants", pipeline)
        
        // Get total count for pagination
        countPipeline ← SLICE(pipeline, 0, 3)  // Only include filter stages
        countResult ← ExecuteAggregation("consultants", [
            ...countPipeline,
            { $count: "total" }
        ])
        
        total ← countResult[0].total IF countResult.length > 0 ELSE 0
        
    ELSE
        // Step 4: Simple query without search (no aggregation needed)
        consultants ← FindConsultants(baseFilter)
            .POPULATE("userId", "name email profileImage isOnline isBanned")
            .SORT({ averageRating: -1, createdAt: -1 })
            .SKIP(skip)
            .LIMIT(limit)
        
        total ← CountDocuments(baseFilter)
    END IF
    
    // Step 5: Calculate pagination metadata
    totalPages ← CEILING(total / limit)
    hasNextPage ← page < totalPages
    hasPrevPage ← page > 1
    
    // Step 6: Return results with metadata
    RETURN {
        consultants: consultants,
        pagination: {
            page: page,
            limit: limit,
            total: total,
            pages: totalPages,
            hasNextPage: hasNextPage,
            hasPrevPage: hasPrevPage
        }
    }
END ALGORITHM


================================================================================
6. ADMIN DASHBOARD - CONSULTANT VERIFICATION ALGORITHM
================================================================================

Algorithm Type: Document Verification Workflow with State Machine
Location: backend/src/modules/admin/admin.service.ts

Description:
Multi-step verification process for consultant identity documents with 
status tracking and automated notifications.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM VerifyConsultantProfile(consultantId, adminId, decision)
INPUT: consultantId (ObjectId), adminId (ObjectId), decision (String)
OUTPUT: Updated consultant with verification status

BEGIN
    // Step 1: Fetch consultant profile
    consultant ← FetchConsultantById(consultantId)
    
    IF consultant = NULL THEN
        THROW Error("Consultant not found")
    END IF
    
    // Step 2: Validate consultant state
    IF consultant.isVerified = TRUE AND decision = "approve" THEN
        THROW Error("Consultant already verified")
    END IF
    
    IF consultant.userId.isBanned = TRUE THEN
        THROW Error("Cannot verify banned user")
    END IF
    
    // Step 3: Check required documents
    IF decision = "approve" THEN
        IF consultant.idCardFront = NULL OR consultant.idCardBack = NULL THEN
            THROW Error("ID card documents missing")
        END IF
        
        IF consultant.title = NULL OR consultant.bio = NULL THEN
            THROW Error("Profile information incomplete")
        END IF
        
        IF LENGTH(consultant.skills) = 0 OR LENGTH(consultant.specialization) = 0 THEN
            THROW Error("Skills and specialization required")
        END IF
    END IF
    
    // Step 4: Process verification decision
    BEGIN_TRANSACTION
    
    TRY
        IF decision = "approve" THEN
            // Approve consultant
            UpdateConsultant(consultantId, {
                isVerified: TRUE,
                verificationStatus: "approved",
                verifiedBy: adminId,
                verifiedAt: CurrentTime(),
                availability: "available"
            })
            
            // Create verification record
            verificationRecord ← {
                consultantId: consultantId,
                adminId: adminId,
                decision: "approved",
                timestamp: CurrentTime(),
                documentsReviewed: [
                    consultant.idCardFront,
                    consultant.idCardBack
                ]
            }
            SaveVerificationRecord(verificationRecord)
            
            // Send approval notification
            SendNotification(consultant.userId, {
                type: "verification_approved",
                title: "Profile Verified!",
                message: "Your consultant profile has been approved. You can now start bidding on projects.",
                priority: "high"
            })
            
            // Send welcome email
            SendEmail(consultant.userId.email, {
                template: "consultant_welcome",
                data: {
                    name: consultant.userId.name,
                    profileLink: "https://expertaah.com/profile"
                }
            })
            
        ELSE IF decision = "decline" THEN
            // Decline consultant
            UpdateConsultant(consultantId, {
                isVerified: FALSE,
                verificationStatus: "declined",
                reviewedBy: adminId,
                reviewedAt: CurrentTime()
            })
            
            // Create verification record
            verificationRecord ← {
                consultantId: consultantId,
                adminId: adminId,
                decision: "declined",
                timestamp: CurrentTime()
            }
            SaveVerificationRecord(verificationRecord)
            
            // Send decline notification
            SendNotification(consultant.userId, {
                type: "verification_declined",
                title: "Verification Pending",
                message: "Please ensure all documents are clear and information is complete. You can resubmit.",
                priority: "high"
            })
            
        ELSE
            THROW Error("Invalid verification decision")
        END IF
        
        COMMIT_TRANSACTION
        
        // Step 5: Return updated consultant
        updatedConsultant ← FetchConsultantById(consultantId)
        RETURN updatedConsultant
        
    CATCH Exception e
        ROLLBACK_TRANSACTION
        THROW Error("Verification failed: " + e.message)
    END TRY
END ALGORITHM


================================================================================
7. ESCROW PAYMENT RELEASE ALGORITHM
================================================================================

Algorithm Type: Conditional Release Protocol with Multi-Party Verification
Location: backend/src/modules/order/order.service.ts

Description:
Secure escrow management that releases payment to consultant upon buyer 
approval or milestone completion with dispute resolution support.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM ReleaseEscrowPayment(orderId, releaseData, requesterId)
INPUT: orderId, releaseData {amount, reason}, requesterId
OUTPUT: paymentRelease with updated balances

BEGIN
    // Step 1: Fetch and validate order
    order ← FetchOrderById(orderId)
    
    IF order = NULL THEN
        THROW Error("Order not found")
    END IF
    
    IF order.status ≠ "completed" AND order.status ≠ "delivered" THEN
        THROW Error("Order must be completed before payment release")
    END IF
    
    // Step 2: Verify requester authorization
    IF requesterId ≠ order.buyerId THEN
        THROW Error("Only buyer can release payment")
    END IF
    
    // Step 3: Check escrow balance
    escrow ← FetchEscrow({ orderId: orderId, status: "held" })
    
    IF escrow = NULL THEN
        THROW Error("No funds held in escrow for this order")
    END IF
    
    releaseAmount ← releaseData.amount
    
    IF releaseAmount > escrow.amount THEN
        THROW Error("Release amount exceeds escrow balance")
    END IF
    
    IF releaseAmount < 0 THEN
        THROW Error("Invalid release amount")
    END IF
    
    // Step 4: Calculate platform fee (10%)
    platformFeePercentage ← 0.10
    platformFee ← releaseAmount * platformFeePercentage
    consultantPayout ← releaseAmount - platformFee
    
    // Step 5: Process payment release transaction
    BEGIN_TRANSACTION
    
    TRY
        // Update escrow record
        UpdateEscrow(escrow.id, {
            status: "released",
            releaseAmount: releaseAmount,
            releaseDate: CurrentTime(),
            releasedBy: requesterId,
            releaseReason: releaseData.reason
        })
        
        // Create payout record
        payout ← {
            orderId: orderId,
            consultantId: order.consultantId,
            amount: consultantPayout,
            platformFee: platformFee,
            grossAmount: releaseAmount,
            status: "completed",
            paymentMethod: "bank_transfer",
            processedAt: CurrentTime()
        }
        SavePayout(payout)
        
        // Update consultant balance
        consultant ← FetchConsultantById(order.consultantId)
        UpdateConsultant(consultant.id, {
            totalEarnings: consultant.totalEarnings + consultantPayout,
            availableBalance: consultant.availableBalance + consultantPayout
        })
        
        // Update order financial records
        UpdateOrder(orderId, {
            amountReleased: order.amountReleased + releaseAmount,
            amountPending: order.amountPending - releaseAmount,
            paymentReleaseDate: CurrentTime(),
            status: "payment_released"
        })
        
        // Create transaction history
        transaction ← {
            orderId: orderId,
            type: "escrow_release",
            amount: releaseAmount,
            from: "escrow",
            to: consultant.userId,
            status: "completed",
            timestamp: CurrentTime(),
            metadata: {
                platformFee: platformFee,
                consultantPayout: consultantPayout,
                releaseReason: releaseData.reason
            }
        }
        SaveTransaction(transaction)
        
        // Send notifications
        SendNotification(consultant.userId, {
            type: "payment_received",
            title: "Payment Released!",
            message: "Rs " + FormatNumber(consultantPayout) + " has been credited to your account.",
            priority: "high"
        })
        
        SendNotification(order.buyerId, {
            type: "payment_released",
            title: "Payment Released",
            message: "Payment of Rs " + FormatNumber(releaseAmount) + " released to consultant.",
            priority: "medium"
        })
        
        // Update statistics
        IncrementStatistic("total_payouts", consultantPayout)
        IncrementStatistic("platform_revenue", platformFee)
        
        COMMIT_TRANSACTION
        
        RETURN {
            success: TRUE,
            payout: payout,
            consultant: consultant,
            order: order,
            message: "Payment released successfully"
        }
        
    CATCH Exception e
        ROLLBACK_TRANSACTION
        THROW Error("Payment release failed: " + e.message)
    END TRY
END ALGORITHM


================================================================================
8. PROPOSAL SUBMISSION AND DUPLICATE PREVENTION ALGORITHM
================================================================================

Algorithm Type: Unique Constraint Validation with Business Logic
Location: backend/src/modules/proposal/proposal.service.ts

Description:
Ensures consultants can only submit one proposal per job with validation
of requirements and automatic proposal count tracking.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM SubmitProposal(proposalData, consultantId)
INPUT: proposalData {jobId, bidAmount, deliveryTime, coverLetter}, consultantId
OUTPUT: Created proposal with job update

BEGIN
    // Step 1: Extract and validate input
    jobId ← proposalData.jobId
    bidAmount ← proposalData.bidAmount
    deliveryTime ← proposalData.deliveryTime
    coverLetter ← proposalData.coverLetter
    
    // Step 2: Validate proposal data
    IF bidAmount < 1000 THEN
        THROW Error("Minimum bid amount is Rs 1000")
    END IF
    
    IF LENGTH(coverLetter) < 100 THEN
        THROW Error("Cover letter must be at least 100 characters")
    END IF
    
    IF LENGTH(deliveryTime) < 3 THEN
        THROW Error("Please specify delivery timeline")
    END IF
    
    // Step 3: Fetch job and validate status
    job ← FetchJobById(jobId)
    
    IF job = NULL THEN
        THROW Error("Job not found")
    END IF
    
    IF job.status ≠ "open" THEN
        THROW Error("Job is no longer accepting proposals")
    END IF
    
    // Step 4: Check for duplicate proposal
    existingProposal ← FindProposal({
        jobId: jobId,
        consultantId: consultantId
    })
    
    IF existingProposal EXISTS THEN
        THROW Error("You have already submitted a proposal for this job")
    END IF
    
    // Step 5: Validate consultant eligibility
    consultant ← FetchConsultantById(consultantId)
    
    IF consultant = NULL THEN
        THROW Error("Consultant profile not found")
    END IF
    
    IF consultant.isVerified = FALSE THEN
        THROW Error("Only verified consultants can submit proposals")
    END IF
    
    IF consultant.userId.isBanned = TRUE THEN
        THROW Error("Your account has been suspended")
    END IF
    
    // Step 6: Check budget compatibility
    IF bidAmount < job.budget.min THEN
        THROW Error("Bid amount below minimum budget")
    END IF
    
    IF bidAmount > job.budget.max * 1.5 THEN
        THROW Error("Bid amount significantly exceeds budget")
    END IF
    
    // Step 7: Create proposal
    BEGIN_TRANSACTION
    
    TRY
        proposal ← {
            jobId: jobId,
            consultantId: consultantId,
            bidAmount: bidAmount,
            deliveryTime: deliveryTime,
            coverLetter: coverLetter,
            status: "pending",
            submittedAt: CurrentTime()
        }
        
        savedProposal ← SaveProposal(proposal)
        
        // Step 8: Update job proposal count
        UpdateJob(jobId, {
            proposalsCount: INCREMENT(1),
            lastProposalDate: CurrentTime()
        })
        
        // Step 9: Notify job owner
        SendNotification(job.buyerId, {
            type: "new_proposal",
            title: "New Proposal Received",
            message: consultant.userId.name + " submitted a proposal for Rs " + FormatNumber(bidAmount),
            priority: "medium",
            link: "/buyer-dashboard/proposals/" + savedProposal.id
        })
        
        // Step 10: Create activity log
        LogActivity({
            type: "proposal_submitted",
            userId: consultant.userId,
            consultantId: consultantId,
            jobId: jobId,
            proposalId: savedProposal.id,
            timestamp: CurrentTime()
        })
        
        COMMIT_TRANSACTION
        
        // Step 11: Populate and return
        populatedProposal ← PopulateProposal(savedProposal, [
            "jobId",
            "consultantId.userId"
        ])
        
        RETURN populatedProposal
        
    CATCH Exception e
        ROLLBACK_TRANSACTION
        
        IF e.code = 11000 THEN  // MongoDB duplicate key error
            THROW Error("Duplicate proposal detected")
        ELSE
            THROW Error("Proposal submission failed: " + e.message)
        END IF
    END TRY
END ALGORITHM


================================================================================
HELPER FUNCTIONS AND UTILITIES
================================================================================

FUNCTION GenerateRandomOTP(length)
BEGIN
    digits ← "0123456789"
    otp ← ""
    FOR i ← 1 TO length DO
        randomIndex ← RandomInteger(0, 9)
        otp ← otp + digits[randomIndex]
    END FOR
    RETURN otp
END FUNCTION


FUNCTION HashWithSHA256(input)
BEGIN
    hash ← SHA256(input)
    RETURN ToHexString(hash)
END FUNCTION


FUNCTION ExtractNumbersFromText(text)
BEGIN
    regex ← /\d+/g
    matches ← text.MATCH(regex)
    numbers ← []
    FOR EACH match IN matches DO
        APPEND ToInteger(match) TO numbers
    END FOR
    RETURN numbers
END FUNCTION


FUNCTION CountWords(text)
BEGIN
    cleanText ← TRIM(text)
    IF LENGTH(cleanText) = 0 THEN
        RETURN 0
    END IF
    words ← SPLIT(cleanText, /\s+/)
    RETURN LENGTH(words)
END FUNCTION


FUNCTION ExtractYearsFromExperience(experienceString)
BEGIN
    regex ← /(\d+)\s*(year|yr)/i
    match ← experienceString.MATCH(regex)
    IF match EXISTS THEN
        RETURN ToInteger(match[1])
    END IF
    RETURN 0
END FUNCTION


FUNCTION GenerateTransactionId()
BEGIN
    timestamp ← CurrentTime().ToUnixTime()
    random ← GenerateRandomString(8)
    RETURN "TXN" + timestamp + random
END FUNCTION


FUNCTION FormatNumber(number)
BEGIN
    RETURN number.ToLocaleString("en-PK")
END FUNCTION


================================================================================
COMPLEXITY ANALYSIS
================================================================================

1. AI Matching Algorithm:
   - Time Complexity: O(n * m) where n = consultants, m = required skills
   - Space Complexity: O(n) for storing matches
   - Optimizations: Database indexing on specialization, skills, rating

2. Intake Assistant:
   - Time Complexity: O(1) per message (state machine)
   - Space Complexity: O(k) where k = conversation state size
   - Optimizations: Caching conversation state, indexed skill lookup

3. Payment Processing:
   - Time Complexity: O(1) for OTP operations
   - Space Complexity: O(1) per session
   - Optimizations: Redis caching for sessions, indexed queries

4. Real-time Messaging:
   - Time Complexity: O(1) for message delivery
   - Space Complexity: O(c) where c = concurrent connections
   - Optimizations: Socket.io rooms, message batching

5. Search Algorithm:
   - Time Complexity: O(log n) with indexes, O(n) without
   - Space Complexity: O(k) where k = result set size
   - Optimizations: MongoDB text indexes, compound indexes

6. Verification Workflow:
   - Time Complexity: O(1) for status updates
   - Space Complexity: O(1)
   - Optimizations: Transactional operations, indexed status field

7. Escrow Release:
   - Time Complexity: O(1) for release operations
   - Space Complexity: O(1)
   - Optimizations: Database transactions, indexed order lookups

8. Proposal Submission:
   - Time Complexity: O(1) with unique index
   - Space Complexity: O(1)
   - Optimizations: Compound unique index (jobId, consultantId)

================================================================================
9. USER AUTHENTICATION AND REGISTRATION ALGORITHM
================================================================================

Algorithm Type: Secure Authentication with Password Hashing and JWT Token Generation
Location: backend/src/modules/auth/auth.service.ts

Description:
Handles user registration and login with bcrypt password hashing and JWT token
generation for secure authentication across buyer, consultant, and admin roles.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM RegisterUser(userData)
INPUT: userData {name, email, password, accountType}
OUTPUT: {token, user}

BEGIN
    // Step 1: Validate input
    IF LENGTH(userData.email) = 0 OR LENGTH(userData.password) = 0 THEN
        THROW Error("Email and password required")
    END IF
    
    IF userData.accountType ≠ "buyer" AND userData.accountType ≠ "consultant" THEN
        THROW Error("Invalid account type")
    END IF
    
    IF LENGTH(userData.password) < 6 THEN
        THROW Error("Password must be at least 6 characters")
    END IF
    
    // Step 2: Check email uniqueness
    existingUser ← FindUserByEmail(userData.email)
    
    IF existingUser EXISTS THEN
        THROW Error("Email already registered")
    END IF
    
    // Step 3: Hash password with bcrypt
    saltRounds ← 10
    hashedPassword ← Bcrypt.Hash(userData.password, saltRounds)
    
    // Step 4: Create user document
    newUser ← {
        name: userData.name,
        email: Lowercase(userData.email),
        password: hashedPassword,
        accountType: userData.accountType,
        roles: ["user"],
        isVerified: FALSE,
        isBanned: FALSE,
        isOnline: FALSE,
        createdAt: CurrentTime()
    }
    
    SaveUser(newUser)
    
    // Step 5: Generate JWT token
    tokenPayload ← {
        id: newUser.id,
        roles: newUser.roles
    }
    
    token ← JWT.Sign(tokenPayload, SECRET_KEY, {
        expiresIn: "7d"
    })
    
    // Step 6: Remove password from response
    DELETE newUser.password
    
    RETURN {
        token: token,
        user: newUser
    }
END ALGORITHM


ALGORITHM LoginUser(credentials)
INPUT: credentials {email, password}
OUTPUT: {token, user}

BEGIN
    // Step 1: Validate input
    IF LENGTH(credentials.email) = 0 OR LENGTH(credentials.password) = 0 THEN
        THROW Error("Email and password required")
    END IF
    
    // Step 2: Find user by email (include password for comparison)
    user ← FindUserByEmail(credentials.email, includePassword=TRUE)
    
    IF user = NULL THEN
        THROW Error("Invalid email or password")
    END IF
    
    // Step 3: Check if user is banned
    IF user.isBanned = TRUE THEN
        THROW Error("Account has been suspended")
    END IF
    
    // Step 4: Verify password with bcrypt
    passwordMatch ← Bcrypt.Compare(credentials.password, user.password)
    
    IF passwordMatch = FALSE THEN
        THROW Error("Invalid email or password")
    END IF
    
    // Step 5: Update online status
    UpdateUser(user.id, {
        isOnline: TRUE,
        lastSeen: CurrentTime()
    })
    
    // Step 6: Generate JWT token
    tokenPayload ← {
        id: user.id,
        roles: user.roles
    }
    
    token ← JWT.Sign(tokenPayload, SECRET_KEY, {
        expiresIn: "7d"
    })
    
    // Step 7: Remove password from response
    DELETE user.password
    
    RETURN {
        token: token,
        user: user
    }
END ALGORITHM


================================================================================
10. JOB CREATION WITH AI ENHANCEMENT ALGORITHM
================================================================================

Algorithm Type: Natural Language Processing with AI-Powered Enhancement
Location: backend/src/modules/job/job.service.ts, backend/src/services/groq.service.ts

Description:
Creates job postings with AI-powered title generation and description enhancement
using Groq AI (Llama 3), along with automatic skill extraction and budget parsing.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM CreateJobWithAIEnhancement(jobData, buyerId)
INPUT: jobData {category, description, budget, timeline, location, skills}, buyerId
OUTPUT: Created job with AI-enhanced title and description

BEGIN
    // Step 1: Validate required fields
    IF LENGTH(jobData.description) < 50 THEN
        THROW Error("Description must be at least 50 characters")
    END IF
    
    IF jobData.budget.min < 1000 THEN
        THROW Error("Minimum budget is Rs 1000")
    END IF
    
    IF jobData.budget.max < jobData.budget.min THEN
        THROW Error("Maximum budget must be greater than minimum")
    END IF
    
    // Step 2: AI Enhancement - Generate professional title and description
    IF LENGTH(jobData.title) = 0 THEN
        aiPrompt ← ConstructPrompt({
            category: jobData.category,
            rawDescription: jobData.description,
            skills: jobData.skills
        })
        
        aiResponse ← CallGroqAPI({
            model: "llama-3.3-70b-versatile",
            temperature: 0.6,
            prompt: aiPrompt,
            expectedFormat: "JSON"
        })
        
        enhancementData ← ParseJSONResponse(aiResponse)
        jobData.title ← enhancementData.title
        jobData.description ← enhancementData.enhancedDescription
    END IF
    
    // Step 3: Extract skills if not provided
    IF LENGTH(jobData.skills) = 0 THEN
        skillsPrompt ← "Extract professional skills from: " + jobData.description
        
        skillsResponse ← CallGroqAPI({
            model: "llama-3.3-70b-versatile",
            temperature: 0.3,
            prompt: skillsPrompt
        })
        
        jobData.skills ← ParseJSONArray(skillsResponse)
        jobData.skills ← SLICE(jobData.skills, 0, 6)  // Limit to 6 skills
    END IF
    
    // Step 4: Create job document
    job ← {
        buyerId: buyerId,
        category: jobData.category,
        title: jobData.title,
        description: jobData.description,
        budget: {
            min: jobData.budget.min,
            max: jobData.budget.max
        },
        timeline: jobData.timeline,
        location: NormalizeLocation(jobData.location),
        skills: jobData.skills,
        attachments: jobData.attachments OR [],
        status: "open",
        proposalsCount: 0,
        createdAt: CurrentTime()
    }
    
    savedJob ← SaveJob(job)
    
    // Step 5: Generate embeddings for AI matching (async)
    IF savedJob.skills.length > 0 THEN
        jobText ← CreateJobText(savedJob)
        embedding ← GenerateEmbedding(jobText)
        
        UpdateJob(savedJob.id, {
            skillsEmbedding: embedding,
            embeddingGeneratedAt: CurrentTime()
        })
    END IF
    
    // Step 6: Send notification to nearby consultants
    matchingConsultants ← FindConsultantsBySpecialization(jobData.category, jobData.location)
    
    FOR EACH consultant IN matchingConsultants DO
        SendNotification(consultant.userId, {
            type: "new_job_posted",
            title: "New Job in Your Area",
            message: "A job matching your skills has been posted",
            link: "/jobs/" + savedJob.id
        })
    END FOR
    
    RETURN savedJob.populate("buyerId", "name email profileImage")
END ALGORITHM


FUNCTION NormalizeLocation(rawLocation)
BEGIN
    locationMappings ← {
        "isb": "Islamabad, Pakistan",
        "pindi": "Rawalpindi, Pakistan",
        "lhr": "Lahore, Pakistan",
        "khi": "Karachi, Pakistan",
        "remote": "Remote (Pakistan)",
        "online": "Remote (Pakistan)"
    }
    
    lowerLocation ← Lowercase(TRIM(rawLocation))
    
    IF locationMappings[lowerLocation] EXISTS THEN
        RETURN locationMappings[lowerLocation]
    END IF
    
    // Capitalize first letter of each word
    words ← SPLIT(rawLocation, " ")
    capitalizedWords ← MAP(words, word => Capitalize(word))
    
    RETURN JOIN(capitalizedWords, " ")
END FUNCTION


================================================================================
11. ORDER STATUS MANAGEMENT STATE MACHINE ALGORITHM
================================================================================

Algorithm Type: Finite State Machine with Transition Rules
Location: backend/src/modules/order/order.service.ts

Description:
Manages order lifecycle through defined states with validation rules for
state transitions and automated notifications.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM UpdateOrderStatus(orderId, newStatus, requesterId)
INPUT: orderId, newStatus, requesterId
OUTPUT: Updated order with new status

BEGIN
    // Step 1: Fetch order
    order ← FetchOrderById(orderId)
    
    IF order = NULL THEN
        THROW Error("Order not found")
    END IF
    
    // Step 2: Verify authorization
    isAuthorized ← (requesterId = order.buyerId OR requesterId = order.consultantId)
    
    IF isAuthorized = FALSE THEN
        THROW Error("Unauthorized to update this order")
    END IF
    
    // Step 3: Define valid state transitions
    validTransitions ← {
        "in_progress": ["completed", "cancelled"],
        "completed": [],  // Terminal state
        "cancelled": []   // Terminal state
    }
    
    currentStatus ← order.status
    
    // Step 4: Validate state transition
    IF newStatus = currentStatus THEN
        THROW Error("Order is already in this status")
    END IF
    
    allowedStates ← validTransitions[currentStatus]
    
    IF newStatus NOT IN allowedStates THEN
        THROW Error("Invalid status transition from " + currentStatus + " to " + newStatus)
    END IF
    
    // Step 5: Handle status-specific logic
    BEGIN_TRANSACTION
    
    TRY
        IF newStatus = "completed" THEN
            // Completion requested by consultant
            IF requesterId = order.consultantId THEN
                UpdateOrder(orderId, {
                    completionRequestedAt: CurrentTime(),
                    completionRequestedBy: "consultant"
                })
                
                SendNotification(order.buyerId, {
                    type: "completion_requested",
                    title: "Project Completion Requested",
                    message: "Consultant has marked the project as complete. Please review and confirm.",
                    priority: "high"
                })
                
                RETURN FetchOrderById(orderId)  // Don't change status yet
            END IF
            
            // Completion confirmed by buyer
            IF requesterId = order.buyerId THEN
                UpdateOrder(orderId, {
                    status: "completed",
                    completionDate: CurrentTime(),
                    progress: 100
                })
                
                SendNotification(order.consultantId, {
                    type: "completion_confirmed",
                    title: "Project Marked Complete",
                    message: "Buyer has confirmed project completion",
                    priority: "high"
                })
                
                // Update job status
                UpdateJob(order.jobId, {
                    status: "completed"
                })
            END IF
            
        ELSE IF newStatus = "cancelled" THEN
            // Cancellation logic
            UpdateOrder(orderId, {
                status: "cancelled",
                completionDate: CurrentTime()
            })
            
            UpdateJob(order.jobId, {
                status: "cancelled"
            })
            
            // Notify both parties
            SendNotification(order.buyerId, {
                type: "order_cancelled",
                message: "Order has been cancelled"
            })
            
            SendNotification(order.consultantId, {
                type: "order_cancelled",
                message: "Order has been cancelled"
            })
        END IF
        
        COMMIT_TRANSACTION
        
        RETURN FetchOrderById(orderId)
        
    CATCH Exception e
        ROLLBACK_TRANSACTION
        THROW Error("Status update failed: " + e.message)
    END TRY
END ALGORITHM


ALGORITHM UpdateOrderProgress(orderId, newProgress, consultantId)
INPUT: orderId, newProgress (0-100), consultantId
OUTPUT: Updated order

BEGIN
    // Validate progress value
    IF newProgress < 0 OR newProgress > 100 THEN
        THROW Error("Progress must be between 0 and 100")
    END IF
    
    order ← FetchOrderById(orderId)
    
    // Verify consultant owns this order
    IF order.consultantId ≠ consultantId THEN
        THROW Error("Unauthorized")
    END IF
    
    // Update progress
    UpdateOrder(orderId, {
        progress: newProgress,
        updatedAt: CurrentTime()
    })
    
    // Notify buyer of significant progress milestones
    IF newProgress MOD 25 = 0 AND newProgress > order.progress THEN
        SendNotification(order.buyerId, {
            type: "progress_update",
            title: "Project Progress Update",
            message: "Project is now " + newProgress + "% complete",
            priority: "medium"
        })
    END IF
    
    RETURN FetchOrderById(orderId)
END ALGORITHM


================================================================================
12. FILE UPLOAD AND CLOUD STORAGE ALGORITHM
================================================================================

Algorithm Type: Base64 Encoding with MongoDB Storage
Location: frontend/src/utils/fileHelper.ts, backend/src/models/*.model.ts

Description:
Handles file uploads with client-side validation, base64 encoding for storage,
and secure retrieval for various document types (images, PDFs, IDs).

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM UploadFileWithBase64(file, options)
INPUT: file (File object), options {maxSizeMB, allowedTypes}
OUTPUT: base64String

BEGIN
    // Step 1: Validate file type
    allowedTypes ← options.allowedTypes OR ["image/jpeg", "image/png", "application/pdf"]
    
    IF file.type NOT IN allowedTypes THEN
        THROW Error("Invalid file type: " + file.type)
    END IF
    
    // Step 2: Validate file size
    maxSizeBytes ← (options.maxSizeMB OR 10) * 1024 * 1024
    
    IF file.size > maxSizeBytes THEN
        THROW Error("File size exceeds " + options.maxSizeMB + "MB limit")
    END IF
    
    // Step 3: Read file as base64
    reader ← NEW FileReader()
    
    base64Promise ← NEW Promise((resolve, reject) => {
        reader.onload ← () => {
            base64String ← reader.result
            resolve(base64String)
        }
        
        reader.onerror ← (error) => {
            reject(Error("File read failed: " + error.message))
        }
    })
    
    reader.readAsDataURL(file)
    
    base64String ← AWAIT base64Promise
    
    // Step 4: Extract metadata
    fileMetadata ← {
        filename: file.name,
        mimeType: file.type,
        size: file.size,
        uploadedAt: CurrentTime()
    }
    
    // Step 5: Return base64 with metadata embedded
    RETURN base64String
END ALGORITHM


ALGORITHM UploadConsultantVerificationDocuments(consultantId, documents)
INPUT: consultantId, documents {idCardFront, idCardBack, supportingDocuments[]}
OUTPUT: Updated consultant profile

BEGIN
    // Step 1: Fetch consultant
    consultant ← FetchConsultantById(consultantId)
    
    IF consultant = NULL THEN
        THROW Error("Consultant not found")
    END IF
    
    // Step 2: Validate all required documents
    IF documents.idCardFront = NULL OR documents.idCardBack = NULL THEN
        THROW Error("Both ID card sides are required")
    END IF
    
    // Step 3: Validate base64 format
    FOR EACH docField IN ["idCardFront", "idCardBack"] DO
        IF documents[docField] NOT STARTS WITH "data:image/" THEN
            THROW Error("Invalid image format for " + docField)
        END IF
    END FOR
    
    // Step 4: Update consultant with base64 documents
    updateData ← {
        idCardFront: documents.idCardFront,
        idCardBack: documents.idCardBack,
        isVerified: FALSE,
        verificationStatus: "pending"
    }
    
    IF documents.supportingDocuments EXISTS THEN
        updateData.supportingDocuments ← documents.supportingDocuments
    END IF
    
    UpdateConsultant(consultantId, updateData)
    
    // Step 5: Notify admin for verification
    adminUsers ← FindUsersByRole("admin")
    
    FOR EACH admin IN adminUsers DO
        SendNotification(admin.id, {
            type: "verification_pending",
            title: "New Consultant Verification",
            message: consultant.userId.name + " has submitted documents for verification",
            priority: "high",
            link: "/admin/consultants/" + consultantId
        })
    END FOR
    
    RETURN FetchConsultantById(consultantId)
END ALGORITHM


ALGORITHM DownloadBase64File(base64String, filename)
INPUT: base64String, filename
OUTPUT: Downloaded file to user's device

BEGIN
    // Step 1: Extract MIME type from base64
    mimeTypeMatch ← base64String.MATCH(/data:([^;]+);/)
    mimeType ← mimeTypeMatch ? mimeTypeMatch[1] : "application/octet-stream"
    
    // Step 2: Extract pure base64 data
    base64Data ← base64String.SPLIT(",")[1]
    
    // Step 3: Convert to binary
    binaryString ← atob(base64Data)
    byteArray ← NEW Uint8Array(LENGTH(binaryString))
    
    FOR i ← 0 TO LENGTH(binaryString) - 1 DO
        byteArray[i] ← binaryString.charCodeAt(i)
    END FOR
    
    // Step 4: Create blob
    blob ← NEW Blob([byteArray], { type: mimeType })
    
    // Step 5: Create download link
    url ← URL.createObjectURL(blob)
    link ← document.createElement("a")
    link.href ← url
    link.download ← filename
    
    // Step 6: Trigger download
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    // Step 7: Cleanup
    URL.revokeObjectURL(url)
END ALGORITHM


================================================================================
13. REVIEW AND RATING AGGREGATION ALGORITHM
================================================================================

Algorithm Type: Aggregate Statistics with Real-time Updates
Location: backend/src/modules/review/review.service.ts

Description:
Manages consultant reviews from buyers, calculates average ratings,
and updates consultant profile statistics in real-time.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM SubmitReview(reviewData, buyerId)
INPUT: reviewData {jobId, consultantId, rating, comment}, buyerId
OUTPUT: Created review with updated consultant rating

BEGIN
    // Step 1: Validate rating
    IF reviewData.rating < 1 OR reviewData.rating > 5 THEN
        THROW Error("Rating must be between 1 and 5 stars")
    END IF
    
    IF LENGTH(reviewData.comment) < 10 THEN
        THROW Error("Review comment must be at least 10 characters")
    END IF
    
    // Step 2: Verify order completion
    order ← FindOrder({
        jobId: reviewData.jobId,
        buyerId: buyerId,
        consultantId: reviewData.consultantId,
        status: "completed"
    })
    
    IF order = NULL THEN
        THROW Error("Can only review completed projects")
    END IF
    
    // Step 3: Check for duplicate review
    existingReview ← FindReview({
        jobId: reviewData.jobId,
        buyerId: buyerId
    })
    
    IF existingReview EXISTS THEN
        THROW Error("You have already reviewed this project")
    END IF
    
    // Step 4: Create review
    review ← {
        jobId: reviewData.jobId,
        buyerId: buyerId,
        consultantId: reviewData.consultantId,
        rating: reviewData.rating,
        comment: TRIM(reviewData.comment),
        createdAt: CurrentTime()
    }
    
    savedReview ← SaveReview(review)
    
    // Step 5: Update consultant rating (call aggregation)
    UpdateConsultantRating(reviewData.consultantId)
    
    // Step 6: Notify consultant
    SendNotification(reviewData.consultantId, {
        type: "new_review",
        title: "New Review Received",
        message: "You received a " + reviewData.rating + "-star review",
        priority: "medium"
    })
    
    RETURN savedReview
END ALGORITHM


ALGORITHM UpdateConsultantRating(consultantId)
INPUT: consultantId
OUTPUT: Updated consultant with new average rating

BEGIN
    // Step 1: Fetch all reviews for consultant
    reviews ← FindAllReviews({ consultantId: consultantId })
    
    totalReviews ← LENGTH(reviews)
    
    IF totalReviews = 0 THEN
        // No reviews yet - reset to defaults
        UpdateConsultant(consultantId, {
            averageRating: 0,
            totalReviews: 0
        })
        RETURN
    END IF
    
    // Step 2: Calculate sum of ratings
    totalRating ← 0
    
    FOR EACH review IN reviews DO
        totalRating ← totalRating + review.rating
    END FOR
    
    // Step 3: Calculate average (rounded to 1 decimal)
    averageRating ← totalRating / totalReviews
    averageRating ← ROUND(averageRating * 10) / 10
    
    // Step 4: Calculate rating distribution
    ratingDistribution ← {
        5: 0, 4: 0, 3: 0, 2: 0, 1: 0
    }
    
    FOR EACH review IN reviews DO
        ratingDistribution[review.rating] ← INCREMENT(1)
    END FOR
    
    // Step 5: Update consultant profile
    UpdateConsultant(consultantId, {
        averageRating: averageRating,
        totalReviews: totalReviews,
        ratingDistribution: ratingDistribution,
        lastReviewedAt: CurrentTime()
    })
    
    // Step 6: Update consultant ranking if rating crosses thresholds
    IF averageRating >= 4.5 AND totalReviews >= 10 THEN
        AwardBadge(consultantId, "TOP_RATED")
    END IF
    
    IF averageRating >= 4.8 AND totalReviews >= 25 THEN
        AwardBadge(consultantId, "EXPERT")
    END IF
END ALGORITHM


ALGORITHM GetConsultantReviewsWithPagination(consultantId, page, limit)
INPUT: consultantId, page, limit
OUTPUT: {reviews, pagination}

BEGIN
    // Calculate pagination
    skip ← (page - 1) * limit
    
    // Fetch reviews with buyer details
    reviews ← FindReviews({
        consultantId: consultantId
    })
        .POPULATE("buyerId", "name profileImage")
        .POPULATE("jobId", "title")
        .SORT({ createdAt: -1 })
        .SKIP(skip)
        .LIMIT(limit)
    
    // Get total count
    totalReviews ← CountReviews({ consultantId: consultantId })
    totalPages ← CEILING(totalReviews / limit)
    
    RETURN {
        reviews: reviews,
        pagination: {
            page: page,
            limit: limit,
            total: totalReviews,
            pages: totalPages,
            hasNextPage: page < totalPages,
            hasPrevPage: page > 1
        }
    }
END ALGORITHM


================================================================================
14. ANALYTICS DATA AGGREGATION ALGORITHM
================================================================================

Algorithm Type: MongoDB Aggregation Pipeline with Time-Series Analysis
Location: backend/src/modules/consultant/consultant.service.ts

Description:
Aggregates consultant performance metrics including proposals, earnings,
and engagement statistics with monthly breakdowns for dashboard charts.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM GetConsultantMonthlyStats(consultantId)
INPUT: consultantId
OUTPUT: monthlyStats[] with proposals, earnings, impressions by month

BEGIN
    currentYear ← CURRENT_YEAR()
    
    // Step 1: Aggregate proposals by month
    proposalStats ← AggregateProposals([
        {
            $match: {
                consultantId: ObjectId(consultantId),
                createdAt: {
                    $gte: Date(currentYear, 0, 1),
                    $lt: Date(currentYear + 1, 0, 1)
                }
            }
        },
        {
            $group: {
                _id: { $month: "$createdAt" },
                count: { $sum: 1 },
                accepted: {
                    $sum: { $cond: [{ $eq: ["$status", "accepted"] }, 1, 0] }
                }
            }
        },
        {
            $sort: { "_id": 1 }
        }
    ])
    
    // Step 2: Aggregate earnings by month
    earningsStats ← AggregateOrders([
        {
            $match: {
                consultantId: ObjectId(consultantId),
                status: "completed",
                completionDate: {
                    $gte: Date(currentYear, 0, 1),
                    $lt: Date(currentYear + 1, 0, 1)
                }
            }
        },
        {
            $group: {
                _id: { $month: "$completionDate" },
                revenue: { $sum: "$amountPaid" }
            }
        },
        {
            $sort: { "_id": 1 }
        }
    ])
    
    // Step 3: Aggregate profile views/impressions
    impressionStats ← AggregateAnalytics([
        {
            $match: {
                consultantId: ObjectId(consultantId),
                eventType: "profile_view",
                createdAt: {
                    $gte: Date(currentYear, 0, 1),
                    $lt: Date(currentYear + 1, 0, 1)
                }
            }
        },
        {
            $group: {
                _id: { $month: "$createdAt" },
                impressions: { $sum: 1 }
            }
        },
        {
            $sort: { "_id": 1 }
        }
    ])
    
    // Step 4: Merge data by month
    monthlyStats ← []
    monthNames ← ["Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    
    FOR month ← 1 TO 12 DO
        proposalData ← FIND(proposalStats, (p) => p._id = month)
        earningData ← FIND(earningsStats, (e) => e._id = month)
        impressionData ← FIND(impressionStats, (i) => i._id = month)
        
        monthStats ← {
            month: monthNames[month - 1],
            proposals: proposalData ? proposalData.count : 0,
            acceptedProposals: proposalData ? proposalData.accepted : 0,
            revenue: earningData ? earningData.revenue : 0,
            impressions: impressionData ? impressionData.impressions : 0
        }
        
        APPEND monthStats TO monthlyStats
    END FOR
    
    RETURN monthlyStats
END ALGORITHM


ALGORITHM GetPlatformStatistics()
INPUT: None
OUTPUT: Platform-wide statistics for admin dashboard

BEGIN
    // Step 1: Count users by type
    totalUsers ← CountDocuments("users")
    totalConsultants ← CountDocuments("users", { accountType: "consultant" })
    totalBuyers ← CountDocuments("users", { accountType: "buyer" })
    
    // Step 2: Count jobs by status
    totalJobs ← CountDocuments("jobs")
    openJobs ← CountDocuments("jobs", { status: "open" })
    completedJobs ← CountDocuments("jobs", { status: "completed" })
    
    // Step 3: Count orders
    totalOrders ← CountDocuments("orders")
    activeOrders ← CountDocuments("orders", { status: "in_progress" })
    
    // Step 4: Calculate revenue
    revenueData ← AggregateOrders([
        {
            $match: { status: "completed" }
        },
        {
            $group: {
                _id: NULL,
                totalRevenue: { $sum: "$totalAmount" },
                platformFee: { $sum: { $multiply: ["$totalAmount", 0.10] } }
            }
        }
    ])
    
    totalRevenue ← revenueData[0] ? revenueData[0].totalRevenue : 0
    platformRevenue ← revenueData[0] ? revenueData[0].platformFee : 0
    
    // Step 5: Calculate averages
    avgOrderValue ← totalOrders > 0 ? totalRevenue / totalOrders : 0
    
    // Step 6: Count pending verifications
    pendingConsultants ← CountDocuments("consultants", { isVerified: FALSE })
    
    // Step 7: Get recent activity
    recentJobs ← FindJobs()
        .SORT({ createdAt: -1 })
        .LIMIT(5)
        .POPULATE("buyerId", "name")
    
    recentOrders ← FindOrders()
        .SORT({ createdAt: -1 })
        .LIMIT(5)
        .POPULATE("buyerId consultantId", "name")
    
    // Step 8: Compile statistics
    RETURN {
        users: {
            total: totalUsers,
            consultants: totalConsultants,
            buyers: totalBuyers
        },
        jobs: {
            total: totalJobs,
            open: openJobs,
            completed: completedJobs
        },
        orders: {
            total: totalOrders,
            active: activeOrders
        },
        revenue: {
            total: totalRevenue,
            platform: platformRevenue,
            avgOrderValue: ROUND(avgOrderValue, 2)
        },
        pending: {
            consultantVerifications: pendingConsultants
        },
        recentActivity: {
            jobs: recentJobs,
            orders: recentOrders
        }
    }
END ALGORITHM


================================================================================
15. PUSH NOTIFICATION DISPATCH ALGORITHM
================================================================================

Algorithm Type: Event-Driven Notification System with Priority Queuing
Location: backend/src/services/notification.service.ts

Description:
Manages in-app and push notifications with priority levels, read status tracking,
and real-time delivery via Socket.IO for various platform events.

--------------------------------------------------------------------------------
PSEUDOCODE:
--------------------------------------------------------------------------------

ALGORITHM SendNotification(userId, notificationData)
INPUT: userId, notificationData {type, title, message, priority, link}
OUTPUT: Created notification with delivery status

BEGIN
    // Step 1: Validate notification data
    IF LENGTH(notificationData.title) = 0 THEN
        THROW Error("Notification title required")
    END IF
    
    IF LENGTH(notificationData.message) = 0 THEN
        THROW Error("Notification message required")
    END IF
    
    // Step 2: Set default priority if not specified
    IF notificationData.priority = NULL THEN
        notificationData.priority ← "medium"
    END IF
    
    // Step 3: Create notification record
    notification ← {
        userId: userId,
        type: notificationData.type,
        title: notificationData.title,
        message: notificationData.message,
        priority: notificationData.priority,
        link: notificationData.link,
        isRead: FALSE,
        createdAt: CurrentTime()
    }
    
    savedNotification ← SaveNotification(notification)
    
    // Step 4: Check if user is online
    userSocket ← GetSocketByUserId(userId)
    
    IF userSocket EXISTS THEN
        // User is online - send real-time notification
        EMIT_TO_SOCKET(userSocket, "new_notification", {
            id: savedNotification.id,
            type: notificationData.type,
            title: notificationData.title,
            message: notificationData.message,
            priority: notificationData.priority,
            link: notificationData.link,
            timestamp: CurrentTime()
        })
        
        // Update notification as delivered
        UpdateNotification(savedNotification.id, {
            deliveredAt: CurrentTime(),
            deliveryStatus: "delivered"
        })
    ELSE
        // User is offline - queue for next login
        UpdateNotification(savedNotification.id, {
            deliveryStatus: "pending"
        })
    END IF
    
    // Step 5: Send email for high-priority notifications
    IF notificationData.priority = "high" THEN
        user ← FetchUserById(userId)
        
        SendEmail({
            to: user.email,
            subject: notificationData.title,
            template: "notification",
            data: {
                name: user.name,
                title: notificationData.title,
                message: notificationData.message,
                link: notificationData.link
            }
        })
    END IF
    
    RETURN savedNotification
END ALGORITHM


ALGORITHM GetUserNotifications(userId, filters)
INPUT: userId, filters {isRead, type, limit, page}
OUTPUT: {notifications, pagination}

BEGIN
    // Build query
    query ← {
        userId: userId
    }
    
    IF filters.isRead IS NOT NULL THEN
        query.isRead ← filters.isRead
    END IF
    
    IF filters.type EXISTS THEN
        query.type ← filters.type
    END IF
    
    // Pagination
    page ← filters.page OR 1
    limit ← filters.limit OR 20
    skip ← (page - 1) * limit
    
    // Fetch notifications
    notifications ← FindNotifications(query)
        .SORT({ createdAt: -1, priority: -1 })
        .SKIP(skip)
        .LIMIT(limit)
    
    // Get total count
    totalCount ← CountNotifications(query)
    totalPages ← CEILING(totalCount / limit)
    
    // Get unread count
    unreadCount ← CountNotifications({
        userId: userId,
        isRead: FALSE
    })
    
    RETURN {
        notifications: notifications,
        pagination: {
            page: page,
            limit: limit,
            total: totalCount,
            pages: totalPages
        },
        unreadCount: unreadCount
    }
END ALGORITHM


ALGORITHM MarkNotificationsAsRead(userId, notificationIds)
INPUT: userId, notificationIds[]
OUTPUT: Number of updated notifications

BEGIN
    // Update multiple notifications
    updateResult ← UpdateMany("notifications", {
        _id: { $in: notificationIds },
        userId: userId,
        isRead: FALSE
    }, {
        isRead: TRUE,
        readAt: CurrentTime()
    })
    
    updatedCount ← updateResult.modifiedCount
    
    // Emit real-time update to user
    userSocket ← GetSocketByUserId(userId)
    
    IF userSocket EXISTS THEN
        newUnreadCount ← CountNotifications({
            userId: userId,
            isRead: FALSE
        })
        
        EMIT_TO_SOCKET(userSocket, "unread_count_update", {
            count: newUnreadCount
        })
    END IF
    
    RETURN updatedCount
END ALGORITHM


ALGORITHM SendBulkNotifications(userIds, notificationData)
INPUT: userIds[], notificationData
OUTPUT: Number of notifications sent

BEGIN
    sentCount ← 0
    failedCount ← 0
    
    // Process in batches to avoid overwhelming system
    batchSize ← 100
    totalBatches ← CEILING(LENGTH(userIds) / batchSize)
    
    FOR batchIndex ← 0 TO totalBatches - 1 DO
        startIndex ← batchIndex * batchSize
        endIndex ← MIN((batchIndex + 1) * batchSize, LENGTH(userIds))
        batch ← SLICE(userIds, startIndex, endIndex)
        
        // Create notifications for batch
        notificationsToInsert ← []
        
        FOR EACH userId IN batch DO
            notification ← {
                userId: userId,
                type: notificationData.type,
                title: notificationData.title,
                message: notificationData.message,
                priority: notificationData.priority OR "medium",
                link: notificationData.link,
                isRead: FALSE,
                createdAt: CurrentTime()
            }
            
            APPEND notification TO notificationsToInsert
        END FOR
        
        // Bulk insert
        TRY
            InsertMany("notifications", notificationsToInsert)
            sentCount ← sentCount + LENGTH(notificationsToInsert)
            
            // Send real-time notifications to online users
            FOR EACH userId IN batch DO
                userSocket ← GetSocketByUserId(userId)
                
                IF userSocket EXISTS THEN
                    EMIT_TO_SOCKET(userSocket, "new_notification", notificationData)
                END IF
            END FOR
            
        CATCH Exception e
            failedCount ← failedCount + LENGTH(batch)
            LogError("Bulk notification batch failed", e)
        END TRY
        
        // Small delay between batches
        SLEEP(100)  // 100ms
    END FOR
    
    RETURN {
        sent: sentCount,
        failed: failedCount,
        total: LENGTH(userIds)
    }
END ALGORITHM


================================================================================
COMPLEXITY ANALYSIS (CONTINUED)
================================================================================

9. User Authentication:
   - Time Complexity: O(1) for bcrypt hash/compare (constant work factor)
   - Space Complexity: O(1) per session
   - Optimizations: JWT stateless tokens, password salt rounds = 10

10. Job Creation with AI:
   - Time Complexity: O(n) where n = description length for AI processing
   - Space Complexity: O(k) where k = embedding dimensions (768-1024)
   - Optimizations: Async embedding generation, caching AI responses

11. Order State Machine:
   - Time Complexity: O(1) for state transitions
   - Space Complexity: O(1)
   - Optimizations: Indexed status field, transaction support

12. File Upload:
   - Time Complexity: O(n) where n = file size for base64 encoding
   - Space Complexity: O(1.33n) due to base64 overhead
   - Optimizations: Client-side validation, compression before upload

13. Review Aggregation:
   - Time Complexity: O(n) where n = number of reviews for consultant
   - Space Complexity: O(1)
   - Optimizations: Incremental updates, cached average rating

14. Analytics Aggregation:
   - Time Complexity: O(n log n) for MongoDB aggregation with sorting
   - Space Complexity: O(m) where m = number of months
   - Optimizations: Indexed date fields, pre-aggregated monthly data

15. Notification Dispatch:
   - Time Complexity: O(1) for single notification, O(n) for bulk
   - Space Complexity: O(n) where n = number of notifications
   - Optimizations: Batch processing, Socket.IO rooms, priority queues


================================================================================
SECURITY CONSIDERATIONS
================================================================================

AUTHENTICATION & AUTHORIZATION:
  - JWT tokens with 7-day expiration
  - HttpOnly cookies for XSS protection
  - Bcrypt hashing with salt rounds = 10
  - Role-based access control (buyer, consultant, admin)
  - Password minimum length: 6 characters

INPUT VALIDATION:
  - Joi schema validation on all API endpoints
  - File type validation (MIME types)
  - File size limits (10MB default)
  - SQL injection prevention via MongoDB
  - XSS prevention via input sanitization

DATA PROTECTION:
  - Password hashing before storage
  - Sensitive data excluded from responses
  - Base64 encoding for file storage
  - HTTPS for production deployment
  - CORS configuration for trusted origins

RATE LIMITING:
  - API request throttling
  - Login attempt limiting
  - OTP generation rate limits
  - Notification dispatch limits


================================================================================
PERFORMANCE OPTIMIZATIONS
================================================================================

DATABASE INDEXING:
  - Compound indexes on (jobId, consultantId) for proposals
  - Status field indexes for filtering
  - User email unique index
  - Date indexes for time-series queries

CACHING STRATEGIES:
  - Redis for session management
  - Embedded caching for AI-generated content
  - In-memory OTP storage (3-minute expiration)
  - Socket.IO connection pooling

QUERY OPTIMIZATION:
  - Pagination for large datasets
  - Selective field projection
  - Aggregation pipeline optimization
  - Batch operations for bulk updates

FRONTEND OPTIMIZATION:
  - Client-side validation
  - Debounced search inputs
  - Lazy loading for images
  - Code splitting for routes


================================================================================
END OF DOCUMENT
================================================================================
